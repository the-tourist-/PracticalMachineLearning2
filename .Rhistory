hist(training$gyros_dumbbell_z[!is.na(training$gyros_dumbbell)])
hist(training$gyros_dumbbell_z[!is.nan(training$gyros_dumbbell)])
hist(training$gyros_dumbbell_z[!is.na(training$gyros_dumbbell_z)])
hist(training$gyros_dumbbell_z[!is.na(training$gyros_dumbbell_z) && training$gyros_dumbbell_z > 0])
!is.na(training$gyros_dumbbell_z) && training$gyros_dumbbell_z > 0
!is.na(training$gyros_dumbbell_z) & training$gyros_dumbbell_z > 0
hist(training$gyros_dumbbell_z[!is.na(training$gyros_dumbbell_z) & training$gyros_dumbbell_z > 0])
hist(log(training$gyros_dumbbell_z[!is.na(training$gyros_dumbbell_z) & training$gyros_dumbbell_z > 0]))
scaleBC <- preProcess(training, method=c("center", "scale", "BoxCox"), verbose=T)
skew <- sapply(predict(scaleBC, training), function(x) { skewness(x, na.rm=T)}, simplify=T)
kurt <- sapply(predict(scaleBC, training), function(x) { kurtosis(x, na.rm=T)}, simplify=T)
head(sort(kurt, decreasing=T), n=100)
head(sort(skew, decreasing=T), n=100)
head(sort(abs(skew), decreasing=T), n=100)
kurt <- sapply(predict(scalePP, training), function(x) { kurtosis(x, na.rm=T)}, simplify=T)
skew <- sapply(predict(scalePP, training), function(x) { skewness(x, na.rm=T)}, simplify=T)
head(sort(abs(skew), decreasing=T), n=100)
scaleBC <- preProcess(training, method=c("center", "scale", "YeoJohnson"))
kurt <- sapply(predict(scaleBC, training), function(x) { kurtosis(x, na.rm=T)}, simplify=T)
skew <- sapply(predict(scaleBC, training), function(x) { skewness(x, na.rm=T)}, simplify=T)
mean <- sapply(predict(scaleBC, training), function(x) { mean(x, na.rm=T)}, simplify=T)
sd <- sapply(predict(scaleBC, training), function(x) { sd(x)}, simplify=T)
head(sort(kurt, decreasing=T), n=20)
head(sort(skew, decreasing=T), n=100)
myTest <- createDataPartition(y=prediction, p=0.1, list=F)
source('~/GitHub/PracticalMachineLearning/LoadData.R')
source('~/GitHub/PracticalMachineLearning/LoadData.R')
source('~/GitHub/PracticalMachineLearning/LoadData.R')
prediction <- as.factor(fullTraining$classe[-myTest])
myTestPrediction <- as.factor(fullTraining$classe[myTest])
training <- training[-myTest,8:(ncol(fullTraining)-1)]
myTestSet <- training[myTest,8:(ncol(fullTraining)-1)]
training <- fullTraining[-myTest,8:(ncol(fullTraining)-1)]
myTestSet <- fullTraining[myTest,8:(ncol(fullTraining)-1)]
source('~/GitHub/PracticalMachineLearning/LoadData.R')
source('~/GitHub/PracticalMachineLearning/Process.R')
head(sort(mean, decreasing=T), n=20)
head(sort(sd, decreasing=T), n=20)
head(sort(kurt, decreasing=T), n=20)
head(sort(skew, decreasing=T), n=20)
head(sort(mean, decreasing=T), n=20)
head(sort(sd, decreasing=T), n=20)
head(sort(kurt, decreasing=T), n=20)
head(sort(abs(skew), decreasing=T), n=20)
hist(predict(scaleYJ, training)$gyros_forearm_z)
hist(predict(scaleYJ, training)$gyros_forearm_y)
hist(predict(scaleYJ, training)$skewness_roll_dumbell)
hist(predict(scaleYJ, training)$skewness_roll_dumbbell)
?train
?preProcess
source('~/GitHub/PracticalMachineLearning/Process.R')
kurt <- sapply(predict(scaleYJ, training), function(x) { kurtosis(x, na.rm=T)}, simplify=T)
skew <- sapply(predict(scaleYJ, training), function(x) { skewness(x, na.rm=T)}, simplify=T)
mean <- sapply(predict(scaleYJ, training), function(x) { mean(x, na.rm=T)}, simplify=T)
sd <- sapply(predict(scaleYJ, training), function(x) { sd(x)}, simplify=T)
head(sort(mean, decreasing=T), n=20)
head(sort(sd, decreasing=T), n=20)
head(sort(kurt, decreasing=T), n=20)
head(sort(skew, decreasing=T), n=20)
trainingStd <- predict(scaleYJ, training)
myTestStd <- predict(scaleYJ, myTestSet)
testingStd <- predict(scaleYJ, testing)
myTestStd <- predict(scaleYJ, myTestSet)
testingStd <- predict(scaleYJ, testing)
testing <- read.csv("pml-testing.csv", stringsAsFactors=F)
testing <- testing[,8:ncol(testing)]
for (i in 1:ncol(testing))
testing[, i] <- as.numeric(testing[, i])
testingStd <- predict(scaleYJ, testing)
mean(testingStd)
testingStd
mean(testingStd, rm.na=T)
mean(testingStd, na.rm=T)
testing <- read.csv("pml-testing.csv", stringsAsFactors=F)
testing <- testing[,8:ncol(testing)]
for (i in 1:ncol(testing))
testing[, i] <- as.numeric(testing[, i])
str(testing)
testing$classe
testing <- read.csv("pml-testing.csv", stringsAsFactors=F)
testing[,160]
fullTraining[,160]
colnames(fullTraining)[160]
colnames(testing)[160]
testing <- read.csv("pml-testing.csv", stringsAsFactors=F)
testing <- testing[,8:(ncol(testing)-1)]
for (i in 1:ncol(testing))
testing[, i] <- as.numeric(testing[, i])
testingStd <- predict(scaleYJ, testing)
str(extractPCA)
extractPCA <- preProcess(trainingStd, method="pca", thresh=0.9)
sapply(predict(scaleYJ, training), function(x) { sd(x)}, simplify=T)==0
sapply(predict(scaleYJ, training), function(x) { sd(x, na.rm=T)}, simplify=T)==0
sd(training==0)
sd(training)
sd(training, na.rm=T)
sd
sd <- sapply(predict(scaleYJ, training), function(x) { sd(x, na.rm=T)}, simplify=T)
which(sd == 0)
colnames(training)[which(sd == 0)]
badColumns <- colnames(training)[which(sd == 0)]
trainingStd <- trainingStd[, -badColumns]
myTestStd <- predict(scaleYJ, myTestSet)[, -badColumns]
testingStd <- predict(scaleYJ, testing)[, -badColumns]
for (i in 1:ncol(training)) {
trainingStd[abs(trainingStd[, i])>3, i] <- 3 * sign(trainingStd[abs(trainingStd[, i])>3, i])
myTestStd[abs(myTestStd[, i])>3, i] <- 3 * sign(myTestStd[abs(myTestStd[, i])>3, i])
testingStd[abs(testingStd[, i])>3, i] <- 3 * sign(testingStd[abs(testingStd[, i])>3, i])
}
badColumns <- colnames(training)[which(sapply(training, function(x) { sd(x, na.rm=T)}, simplify=T) == 0)]
trainingStd <- predict(scaleYJ, training)[,-badColumns]
badColumns <- sapply(predict(scaleYJ, training), function(x) { sd(x, na.rm=T)}, simplify=T) == 0
trainingStd <- trainingStd[,-badColumns]
badColumns <- which(sapply(predict(scaleYJ, training), function(x) { sd(x, na.rm=T)}, simplify=T) == 0)
badColumns <- which(sapply(training, function(x) { sd(x, na.rm=T)}, simplify=T) == 0)
trainingStd <- trainingStd[,-badColumns]
source('~/GitHub/PracticalMachineLearning/Process.R')
for (i in 1:ncol(training)) {
trainingStd[abs(trainingStd[, i])>3, i] <- 3 * sign(trainingStd[abs(trainingStd[, i])>3, i])
myTestStd[abs(myTestStd[, i])>3, i] <- 3 * sign(myTestStd[abs(myTestStd[, i])>3, i])
testingStd[abs(testingStd[, i])>3, i] <- 3 * sign(testingStd[abs(testingStd[, i])>3, i])
}
for (i in 1:ncol(trainingStd)) {
trainingStd[abs(trainingStd[, i])>3, i] <- 3 * sign(trainingStd[abs(trainingStd[, i])>3, i])
myTestStd[abs(myTestStd[, i])>3, i] <- 3 * sign(myTestStd[abs(myTestStd[, i])>3, i])
testingStd[abs(testingStd[, i])>3, i] <- 3 * sign(testingStd[abs(testingStd[, i])>3, i])
}
trainingStd[abs(trainingStd[, i])>3, i]
trainingStd[abs(trainingStd[, i])>3, i, na,rm=T]
trainingStd[abs(trainingStd[, i])>3, i, na.rm=T]
?[]
?[
?"["
trainingStd[!is.na(trainingStd[, i])) & abs(trainingStd[, i])>3, i]
trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i]
for (i in 1:ncol(training)) {
trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i] <- 3 * sign(trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i])
myTestStd[!is.na(myTestStd[, i]) & abs(myTestStd[, i])>3, i] <- 3 * sign(myTestStd[!is.na(myTestStd[, i]) & abs(myTestStd[, i])>3, i])
testingStd[!is.na(testingStd[, i]) & abs(testingStd[, i])>3, i] <- 3 * sign(testingStd[!is.na(trainingStd[, i]) & abs(testingStd[, i])>3, i])
}
for (i in 1:ncol(training)) {
trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i] <- 3 * sign(trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i])
myTestStd[!is.na(myTestStd[, i]) & abs(myTestStd[, i])>3, i] <- 3 * sign(myTestStd[!is.na(myTestStd[, i]) & abs(myTestStd[, i])>3, i])
testingStd[!is.na(testingStd[, i]) & abs(testingStd[, i])>3, i] <- 3 * sign(testingStd[!is.na(testingStd[, i]) & abs(testingStd[, i])>3, i])
}
for (i in 1:ncol(trainingStd)) {
trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i] <- 3 * sign(trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i])
myTestStd[!is.na(myTestStd[, i]) & abs(myTestStd[, i])>3, i] <- 3 * sign(myTestStd[!is.na(myTestStd[, i]) & abs(myTestStd[, i])>3, i])
testingStd[!is.na(testingStd[, i]) & abs(testingStd[, i])>3, i] <- 3 * sign(testingStd[!is.na(testingStd[, i]) & abs(testingStd[, i])>3, i])
}
extractPCA <- preProcess(trainingStd, method="pca", thresh=0.9)
?preProcess
extractPCA <- preProcess(trainingStd, method="pca", thresh=0.9, verbose=T)
?prcomp
extractPCA <- prcomp(trainingStd, center=F, scale=F)
extractPCA <- prcomp(trainingStd, center=F, scale=F, na.action=na.omit)
str(trainingStd)
extractPCA <- prcomp(na.omit(trainingStd), center=F, scale=F)
na.omit(trainingStd)
?na.omit
extractPCA <- prcomp(na.omit(trainingStd), center=F, scale=F)
dim(na.omit(trainingStd))
dim(na.extend(trainingStd))
dim(na.exclude(trainingStd))
trainingStd
View(trainingStd)
sort(sapply(training, function(x) { mean(!is.na(x)) }, simplify=T), descending=T)
?sort
sort(sapply(training, function(x) { mean(!is.na(x)) }, simplify=T), decreasing=T)
which(sapply(training, function(x) { mean(!is.na(x)) }, simplify=T)>=0.99)
source('~/GitHub/PracticalMachineLearning/Process.R')
source('~/GitHub/PracticalMachineLearning/Process.R')
?sd
source('~/GitHub/PracticalMachineLearning/Process.R')
includeColumns <- which(sapply(training, function(x) { mean(!is.na(x)) >= 0.99 & sd(x, na.rm=T) > 0 }, simplify=T))
source('~/GitHub/PracticalMachineLearning/Process.R')
which(sapply(training, function(x) { mean(!is.na(x)) >= 0.99 & sd(x, na.rm=T) > 0 }, simplify=T))
length(sapply(training, function(x) { mean(!is.na(x)) >= 0.99 & sd(x, na.rm=T) > 0 }, simplify=T))
length(sapply(training, function(x) { mean(!is.na(x)) >= 0.99 }, simplify=T))
sum(sapply(training, function(x) { mean(!is.na(x)) >= 0.99 }, simplify=T))
sum(sapply(training, function(x) { mean(!is.na(x)) >= 0.99 & sd(x, na.rm=T) > 0 }, simplify=T))
sum(sapply(training, function(x) { sd(x, na.rm=T) > 0 }, simplify=T))
sum(sapply(training, function(x) { sd(x, na.rm=T) > 0.01 }, simplify=T))
(sapply(training, function(x) { sd(x, na.rm=T) }, simplify=T))
(sapply(training, function(x) { sd(x, na.rm=T) }, simplify=T))==0
which(sapply(training, function(x) { sd(x, na.rm=T)==0 }, simplify=T))
length(sapply(training, function(x) { sd(x, na.rm=T)==0 }, simplify=T))
length(sapply(training, function(x) { sd(x, na.rm=T)>0 }, simplify=T))
sum(sapply(training, function(x) { sd(x, na.rm=T)>0 }, simplify=T))
sapply(training, function(x) { sd(x, na.rm=T)>0 }, simplify=T)
mean(sapply(training, function(x) { sd(x, na.rm=T)>0 }, simplify=T))
mean(sapply(training, function(x) { sd(x, na.rm=T)>0 }, simplify=T), na.rm=T)
sum(sapply(training, function(x) { sd(x, na.rm=T)>0 }, simplify=T), na.rm=T)
sum(sapply(training, function(x) { sd(x, na.rm=T)=0 }, simplify=T), na.rm=T)
sum(sapply(training, function(x) { sd(x, na.rm=T)==0 }, simplify=T), na.rm=T)
sum(sapply(training, function(x) { ean(!is.na(x)) >= 0.99 & sd(x, na.rm=T)==0 }, simplify=T), na.rm=T)
sum(sapply(training, function(x) { mean(!is.na(x)) >= 0.99 & sd(x, na.rm=T)==0 }, simplify=T), na.rm=T)
includeColumns <- which(sapply(training, function(x) { mean(!is.na(x)) >= 0.99 & sd(x, na.rm=T) > 0 }, simplify=T))
scaleYJ <- preProcess(training, method=c("center", "scale", "YeoJohnson"))
scaleYJ <- preProcess(training[, includeColumns], method=c("center", "scale", "YeoJohnson"))
trainingStd <- predict(scaleYJ, training[, includeColumns])
myTestStd <- predict(scaleYJ, myTestSet[, includeColumns])
testingStd <- predict(scaleYJ, testing[, includeColumns])
sum(sapply(trainingstd, function(x) { sd(x, na.rm=T)==0 }, simplify=T), na.rm=T)
sum(sapply(trainingStd, function(x) { sd(x, na.rm=T)==0 }, simplify=T), na.rm=T)
kurt <- sapply(predict(scaleYJ, training), function(x) { kurtosis(x, na.rm=T)}, simplify=T)
skew <- sapply(predict(scaleYJ, training), function(x) { skewness(x, na.rm=T)}, simplify=T)
sd <- sapply(predict(scaleYJ, training), function(x) { sd(x, na.rm=T)}, simplify=T)
mean <- sapply(predict(scaleYJ, training), function(x) { mean(x, na.rm=T)}, simplify=T)
print(head(sort(mean, decreasing=T), n=20))
print(head(sort(sd, decreasing=T), n=20))
print(head(sort(kurt, decreasing=T), n=20))
print(head(sort(skew, decreasing=T), n=20))
sapply(trainingStd, function(x) { kurtosis(x, na.rm=T)}, simplify=T)
skew <- sapply(trainingStd, function(x) { skewness(x, na.rm=T)}, simplify=T)
sd <- sapply(ptrainingStd, function(x) { sd(x, na.rm=T)}, simplify=T)
mean <- sapply(trainingStd), function(x) { mean(x, na.rm=T)}, simplify=T)
print(head(sort(mean, decreasing=T), n=20))
print(head(sort(sd, decreasing=T), n=20))
print(head(sort(kurt, decreasing=T), n=20))
print(head(sort(skew, decreasing=T), n=20))
scaleYJ <- preProcess(training[, includeColumns], method=c("center", "scale", "YeoJohnson"))
trainingStd <- predict(scaleYJ, training[, includeColumns])
myTestStd <- predict(scaleYJ, myTestSet[, includeColumns])
testingStd <- predict(scaleYJ, testing[, includeColumns])
kurt <- sapply(trainingStd, function(x) { kurtosis(x, na.rm=T)}, simplify=T)
skew <- sapply(trainingStd, function(x) { skewness(x, na.rm=T)}, simplify=T)
sd <- sapply(ptrainingStd, function(x) { sd(x, na.rm=T)}, simplify=T)
mean <- sapply(trainingStd), function(x) { mean(x, na.rm=T)}, simplify=T)
print(head(sort(mean, decreasing=T), n=20))
print(head(sort(sd, decreasing=T), n=20))
print(head(sort(kurt, decreasing=T), n=20))
print(head(sort(skew, decreasing=T), n=20))
scaleYJ <- preProcess(training[, includeColumns], method=c("center", "scale", "YeoJohnson"))
trainingStd <- predict(scaleYJ, training[, includeColumns])
myTestStd <- predict(scaleYJ, myTestSet[, includeColumns])
testingStd <- predict(scaleYJ, testing[, includeColumns])
kurt <- sapply(trainingStd, function(x) { kurtosis(x, na.rm=T)}, simplify=T)
skew <- sapply(trainingStd, function(x) { skewness(x, na.rm=T)}, simplify=T)
sd <- sapply(trainingStd, function(x) { sd(x, na.rm=T)}, simplify=T)
mean <- sapply(trainingStd, function(x) { mean(x, na.rm=T)}, simplify=T)
print(head(sort(mean, decreasing=T), n=20))
print(head(sort(sd, decreasing=T), n=20))
print(head(sort(kurt, decreasing=T), n=20))
print(head(sort(skew, decreasing=T), n=20))
extractPCA <- prComp(trainingStd, thresh=0.9)
extractPCA <- prcomp(trainingStd, thresh=0.9)
plot(extractPCA$x[,1], extractPCA$x[,2], col=prediction)
qplot(extractPCA$x[,1], extractPCA$x[,2], col=prediction)
qplot(extractPCA$x[,3], extractPCA$x[,4], col=prediction)
qplot(extractPCA$x[,5], extractPCA$x[,6], col=prediction)
pairs(extractPCA$x[,1:10], col=prediction)
pairs(extractPCA$x[,1:4], col=alpha(prediction, 0.2))
library(scales)
pairs(extractPCA$x[,1:4], col=alpha(prediction, 0.2))
pairs(extractPCA$x[,1:4], col=alpha(as.integer(prediction), 0.2))
sapply(extractPCA$x, sd)
qplot(extractPCA$sdev)
qplot(extractPCA$sdev, aed="scatter")
qplot(seq_along(extractPCA$sdev), extractPCA$sdev, aed="scatter")
qplot(seq_along(extractPCA$sdev), extractPCA$sdev)
extractPCA <- prcomp(trainingStd, thresh=0.8)
qplot(seq_along(extractPCA$sdev), extractPCA$sdev)
extractPCA <- prcomp(trainingStd, thresh=0.5)
?prcomp
extractPCA <- preProcess(trainingStd, thresh=0.9, method="pca")
?preProcess
pca <- predict(extractPCA, trainingStd)
plot(pca[,1], pca[,2], col=prediction)
qplot(pca[,1], pca[,2], col=prediction)
extractPCA <- preProcess(trainingStd, thresh=0.8, method="pca")
extractPCA <- preProcess(trainingStd, thresh=0.9, method="pca")
qplot(pca[,1:6], col=prediction)
pairs(pca[,1:6], col=prediction)
sort(pca[6], decreasing=T)
sort(pca[,6], decreasing=T)
sort(sapply(training, function(x) { max(abs(x)) }), decreasing=T)
sort(sapply(trainingStd, function(x) { max(abs(x)) }), decreasing=T)
for (i in 1:ncol(trainingStd)) {
trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i] <- 3 * sign(trainingStd[!is.na(trainingStd[, i]) & abs(trainingStd[, i])>3, i])
myTestStd[!is.na(myTestStd[, i]) & abs(myTestStd[, i])>3, i] <- 3 * sign(myTestStd[!is.na(myTestStd[, i]) & abs(myTestStd[, i])>3, i])
testingStd[!is.na(testingStd[, i]) & abs(testingStd[, i])>3, i] <- 3 * sign(testingStd[!is.na(testingStd[, i]) & abs(testingStd[, i])>3, i])
}
sort(sapply(trainingStd, function(x) { max(abs(x)) }), decreasing=T)
extractPCA <- preProcess(trainingStd, thresh=0.9, method="pca")
pairs(pca[,1:6], col=prediction)
pairs(pca[,1:6], col=prediction)
sort(sapply(trainingStd, function(x) { max(abs(x)) }), decreasing=T)
sort(sapply(trainingStd, function(x) { abs(mean(x)) }), decreasing=T)
sort(sapply(trainingStd, function(x) { abs(stdev(x)-1) }), decreasing=T)
sort(sapply(trainingStd, function(x) { abs(ln(sd(x))) }), decreasing=T)
sort(sapply(trainingStd, function(x) { abs(log(sd(x))) }), decreasing=T)
sort(sapply(trainingStd, function(x) { exp(abs(log(sd(x)))) }), decreasing=T)
View(extractPCA)
extractPCA$rotation
View(xtractPCA$rotation)
View(extractPCA$rotation)
table(prediction)
length(prediction)
length(trainingStd)
nrows(trainingStd)
nrow(trainingStd)
pca <- predict(extractPCA, trainingStd)
pairs(pca[,1:6], col=prediction)
extractPCA <- preProcess(trainingStd, thresh=0.8, method="pca")
trainingPCA <- predict(extractPCA, trainingStd)
myTestPCA <- predict(extractPCA, myTestStd)
testingPCA <- predict(extractPCA, testingStd)
model <- train(prediction ~ ., method="glm", data=trainingPCA)
levels(prediction)
prediction <- as.data.frame(classe=as.factor(fullTraining$classe[-myTest]))
prediction <- data.frame(classe=as.factor(fullTraining$classe[-myTest]))
foreach(classe in prediction$classe)
for(classe in prediction$classe)
prediction[,paste("classe", classe, sep="")] = prediction$classe == classe
View(prediction)
modelA <- train(prediction$classeA ~ ., method="glm", data=trainingPCA)
nrow(trainingPCA)
nrow(prediction$classeA)
modelA <- train(prediction[,classeA] ~ ., method="glm", data=trainingPCA)
modelA <- train(prediction[,"classeA"] ~ ., method="glm", data=trainingPCA)
nrow(prediction[,"classeA"])
View(prediction)
class(prediction)
class(prediction$classeA)
length(prediction$classeA)
modelA <- train(prediction$classeA ~ ., method="glm", data=trainingPCA)
pred <- prediction$classeA
modelA <- train(pred ~ ., method="glm", data=trainingPCA)
train(pred ~ ., method="glm", data=trainingPCA)
glm(pred ~ ., data=trainingPCA)
train(pred ~ ., method="glm", data=trainingPCA, family="binomial")
version()
ver()
vers()
version
Sys.getenv("R_ARCH")
glm(pred ~ ., data=trainingPCA, family=binomial)
glm(prediction$classeA ~ ., data=trainingPCA, family=binomial)
glm(prediction$classeA ~ ., data=trainingPCA, family="binomial")
?confusionMatrix
modelA <- glm(prediction$classeA ~ ., data=trainingPCA, family="binomial")
confusionMatrix(predict(modelA, trainingPCA), prediction$classeA)
predict(modelA, trainingPCA)
qplot(seq_over(trainingPCA), predict(modelA, trainingPCA))
qplot(seq_along(trainingPCA), sort(predict(modelA, trainingPCA))
)
length(seq_along(trainingPCA))
qplot(seq_along(prediction$classe), sort(predict(modelA, trainingPCA))
)
modelA <- glm(prediction$classeA ~ ., data=trainingPCA, family="binomial")
min(predict(modelA, trainingPCA))
max(predict(modelA, trainingPCA))
glm(prediction$classeA ~ ., data=trainingPCA)
glm(prediction$classeA ~ ., data=trainingPCA, family="binomial")
modelA <- glm(prediction$classeA ~ ., data=trainingPCA, family="binomial")
max(predict(modelA, trainingPCA))
max(predict(modelA, trainingPCA, response="response"))
max(predict(modelA, trainingPCA, type="response"))
min(predict(modelA, trainingPCA, type="response"))
qplot(seq_along(prediction$classe), sort(predict(modelA, trainingPCA, type="response")))
confusionMatrix(prediction$classeA, predict(modelA, trainingPCA, type="response")>0.5))
confusionMatrix(prediction$classeA, predict(modelA, trainingPCA, type="response")>0.5)
plot(1:100/100, confusionMatrix(prediction$classeA, predict(modelA, trainingPCA, type="response")$Accuracy>1:100/100)
)
confusionMatrix(prediction$classeA, predict(modelA, trainingPCA, type="response")0.4)
confusionMatrix(prediction$classeA, predict(modelA, trainingPCA, type="response")>0.4)
confusionMatrix(prediction$classeA, predict(modelA, trainingPCA, type="response")>0.6)
confusionMatrix(prediction$classeA, predict(modelA, trainingPCA, type="response")>0.5)
source('~/GitHub/PracticalMachineLearning/LoadData.R')
source('~/GitHub/PracticalMachineLearning/LoadData.R')
myTestPrediction <- as.factor(fullTraining$classe[myTest])
for(classe in myTestPrediction$classe)
myTestPrediction[,paste("classe", classe, sep="")] = myTestPrediction$classe == classe
myTestPrediction <- data.frame(classe=as.factor(fullTraining$classe[myTest]))
for(classe in myTestPrediction$classe)
myTestPrediction[,paste("classe", classe, sep="")] = myTestPrediction$classe == classe
training <- fullTraining[-myTest,8:(ncol(fullTraining)-1)]
myTestSet <- fullTraining[myTest,8:(ncol(fullTraining)-1)]
for (i in 1:ncol(training)) {
training[, i] <- as.numeric(training[, i])
myTestSet[, i] <- as.numeric(myTestSet[, i])
}
testing <- read.csv("pml-testing.csv", stringsAsFactors=F)
testing <- testing[,8:(ncol(testing)-1)]
for (i in 1:ncol(testing))
testing[, i] <- as.numeric(testing[, i])
rm(list=ls())
source('~/GitHub/PracticalMachineLearning/LoadData.R')
?train
train(trainingPCA, classification$classeA, method="glm")
source('~/GitHub/PracticalMachineLearning/Process.R')
pairs(trainingPCA[,1:6], col=classification$classe)
classification <- data.frame(classe=as.factor(fullTraining$classe[-myTest]))
for(classe in classification$classe)
classification[,classe] = classification$classe == classe
myTestClassification <- data.frame(classe=as.factor(fullTraining$classe[myTest]))
for(classe in myTestClassification$classe)
myTestClassification[,classe] = myTestClassification$classe == classe
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
for(classe in classification$classe) print(classe)
for(classe in levles(classification$classe)) print(classe)
for(classe in levels(classification$classe)) print(classe)
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
for(classe in levels(classification$classe))
train(trainingPCA, classification[class], method="glm")
for(classe in levels(classification$classe))
train(trainingPCA, classification[,class], method="glm")
train(trainingPCA, classification[,"A"], method="glm")
train(trainingPCA, classification[,1], method="glm")
train(classification[,1] ~ ., method="glm", data=trainingPCA)
train(classification[,1] ~ ., method="glm", data=trainingPCA, family=binomial)
train(classification$A ~ ., method="glm", data=trainingPCA, family=binomial)
nrow(classification$A)
View(classification)
nrow(classification[,"A"])
nrow(classification[,1])
classification
str(classification)
str(classification$A)
length(classification$A)
?train
train(trainingPCA, as.numeric(classification$A), method="glm", family=binomial)
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
regressionModels
regressionModels["A"] <- "A"
regressionModels["A"] <- list(A=1, B=2)
regressionModels <- data.frame()
regressionModels["A"] <- list(A=1, B=2)
model <- train(trainingPCA, as.numeric(classification[,classe]), method="glm", family=binomial, trControl=tc)
regressionModels[["A"]] <- model
class(model)
model
str(model)
model$times
model <- train(trainingPCA, as.numeric(classification[,classe]), method="glm", family=binomial)
names(getModelInfo()
)
model <- train(trainingPCA, as.numeric(classification[,classe]), method="glmStepAIC", family=binomial)
model
str(model)
model$anova
regressionModels <- list()
regressionModels[[1]] <- model
regressionModels[["A"]] <- model
regressionModels[[classe]] <- model
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
predictions <- list()
for(classe in levels(classification$classe))
predictions[[classe]] <- predict(regressionModels[[classe]], trainingPCA, type="response")
predictions <- list()
for(classe in levels(classification$classe))
predictions[[classe]] <- predict(regressionModels[[classe]], trainingPCA, type="prob")
pridictions[["A"]] <- predict(regressionModels[[classe]], trainingPCA, type="prob")
regressionModels[["A"]]
?predict
predictions[["A"]] <- predict(regressionModels[[classe]], trainingPCA)
predictions[["A"]] <- predict(regressionModels[[classe]], trainingPCA, type="response")
predictions[["A"]] <- predict(regressionModels[[classe]], trainingPCA, type="responses")
predictions[["A"]] <- predict(regressionModels[[classe]], trainingPCA, type="prob")
predictions <- list()
for(classe in levels(classification$classe))
predictions[[classe]] <- predict(regressionModels[[classe]], trainingPCA)
head(predictions)
head(predictions, n=6)
View(predictions)
which(max(predictions))
?max
apply(predictions, 1, max)
apply(predictions, 2, max)
head(apply(as.matrix(predictions), 1, max))
head(as.matrix(predictions))
head(as.matrix(predictions), size=10)
View(as.matrix(predictions))
View(as.data.frame(predictions))
apply(as.data.frame(predictions), 2, max)
head(apply(as.data.frame(predictions), 1, max))
head(apply(as.data.frame(predictions), 1, function(x) which(max(x))))
head(apply(as.data.frame(predictions), 1, function(x) which(x==max(x))))
head(apply(as.data.frame(predictions), 1, function(x) rownames(x)[which(x==max(x))]))
head(apply(as.data.frame(predictions), 1, function(x) names(x)[which(x==max(x))]))
predictions$prediction <- apply(as.data.frame(predictions), 1, function(x) names(x)[which(x==max(x))])
confusionMatrix(predictions$prediction, classifications$classe)
confusionMatrix(predictions$prediction, classification$classe)
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
myTestPrediction <- list()
for(classe in levels(myTestClassification$classe))
myTestPrediction[[classe]] <- predict(regressionModels[[classe]], trainingPCA)
myTestPrediction$classe <- apply(as.data.frame(myTestPrediction), 1, function(x) names(x)[which(x==max(x))])
confusionMatrix(myTestPrediction$classe, myTestClassification$classe)
myTestPrediction <- list()
for(classe in levels(myTestClassification$classe))
myTestPrediction[[classe]] <- predict(regressionModels[[classe]], myTestPCA)
myTestPrediction$classe <- apply(as.data.frame(myTestPrediction), 1, function(x) names(x)[which(x==max(x))])
confusionMatrix(myTestPrediction$classe, myTestClassification$classe)
source('~/GitHub/PracticalMachineLearning/regressionModels.R')
prediction <- list()
for(classe in levels(classification$classe))
prediction[[classe]] <- predict(regressionModels[[classe]], trainingPCA)
prediction$classe <- apply(as.data.frame(prediction), 1, function(x) names(x)[which(x==max(x))])
confusionMatrix(prediction$classe, classification$classe)
myTestPrediction <- list()
for(classe in levels(myTestClassification$classe))
myTestPrediction[[classe]] <- predict(regressionModels[[classe]], myTestPCA)
myTestPrediction$classe <- apply(as.data.frame(myTestPrediction), 1, function(x) names(x)[which(x==max(x))])
confusionMatrix(myTestPrediction$classe, myTestClassification$classe)
source('~/GitHub/PracticalMachineLearning/Process.R')
